---
--- Generated by Luanalysis
--- Created by swift.
--- DateTime: 10/22/24 14:54
---
--- Eventually, comming back to struct & reference based lua
--- coz other way is just not gonna work

-- to delete
a = {
    val = "a";
    func = function()
        print(io)
        print("printing")
    end
}

a = ocap.ocapify(a)
a.func()

-- to delete




require("verifier")

str1 = "1234 5678 2234 5678"
str2 = "1234 5678 2234 567"
str3 = "aaaa"

-- Test if verifier works
assert(verifier.valid(str1))
assert(verifier.valid(str2))
assert(verifier.valid(str3) == false)

-- Test malicious function
function get_last_line(filename)
    local file = io.open(filename, "r")
    if not file then return nil end

    local lastLine
    for line in file:lines() do
        lastLine = line
    end

    file:close()
    return lastLine:gsub("[%s\r\n]+$", "")
end

s = "To the file from evil validation function\n"
verifier.isValid(s)
--print(get_last_line("././f.txt"))
--print(s)

assert(get_last_line("./f.txt") == s:gsub("[%s\r\n]+$", ""))


---testcases
assert(ocap)
assert(ocap.ocapify)

--- ocapified obj is not the original one
obj = ocap.ocapify(verifier)
obj2 = ocap.ocapify(verifier)
assert(not (obj == verifier))
assert(not (obj2 == verifier))


--- basic function test
assert(obj.receiveCap)
assert(obj.removeCap)


--- obj receive cap, obj2 does not
--ioBackup = io
--io = nil;
--for k, v in pairs(_G) do print(k,v) end

assert(obj.receiveCap(io.write, "io.write"))
obj.receiveCap(io.output, "io.output")
obj.receiveCap(io.open, "io.open")
obj.receiveCap(io.close, "io.close")


--obj.receiveCap(io, "io")

--for k, v in pairs(obj.caps.io) do print(k, v) end


--obj.receiveCap(io, "io")
--assert(obj.caps.io == io)


--- both ocapified object calling evil func
--- input for obj should be on the file, while the obj2 should not

print(obj.isValid(str3))
print(obj2.isValid(str3))

--x = require(socket)

--assert(io == ioBackup)
